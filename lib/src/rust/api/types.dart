// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

class Channel {
  final PlatformInt64? id;
  final String name;
  final String? url;
  final String? group;
  final String? image;
  final int mediaType;
  final PlatformInt64? sourceId;
  final BigInt? seriesId;
  final PlatformInt64? groupId;
  final bool favorite;
  final BigInt? streamId;

  const Channel({
    this.id,
    required this.name,
    this.url,
    this.group,
    this.image,
    required this.mediaType,
    this.sourceId,
    this.seriesId,
    this.groupId,
    required this.favorite,
    this.streamId,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      url.hashCode ^
      group.hashCode ^
      image.hashCode ^
      mediaType.hashCode ^
      sourceId.hashCode ^
      seriesId.hashCode ^
      groupId.hashCode ^
      favorite.hashCode ^
      streamId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Channel &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          url == other.url &&
          group == other.group &&
          image == other.image &&
          mediaType == other.mediaType &&
          sourceId == other.sourceId &&
          seriesId == other.seriesId &&
          groupId == other.groupId &&
          favorite == other.favorite &&
          streamId == other.streamId;
}

class ChannelHttpHeaders {
  final PlatformInt64? id;
  final PlatformInt64? channelId;
  final String? referrer;
  final String? userAgent;
  final String? httpOrigin;
  final bool? ignoreSsl;

  const ChannelHttpHeaders({
    this.id,
    this.channelId,
    this.referrer,
    this.userAgent,
    this.httpOrigin,
    this.ignoreSsl,
  });

  static Future<ChannelHttpHeaders> default_() =>
      RustLib.instance.api.crateApiTypesChannelHttpHeadersDefault();

  @override
  int get hashCode =>
      id.hashCode ^
      channelId.hashCode ^
      referrer.hashCode ^
      userAgent.hashCode ^
      httpOrigin.hashCode ^
      ignoreSsl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelHttpHeaders &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          channelId == other.channelId &&
          referrer == other.referrer &&
          userAgent == other.userAgent &&
          httpOrigin == other.httpOrigin &&
          ignoreSsl == other.ignoreSsl;
}

class EPG {
  final String epgId;
  final String title;
  final String description;
  final String startTime;
  final PlatformInt64 startTimestamp;
  final String endTime;

  const EPG({
    required this.epgId,
    required this.title,
    required this.description,
    required this.startTime,
    required this.startTimestamp,
    required this.endTime,
  });

  @override
  int get hashCode =>
      epgId.hashCode ^
      title.hashCode ^
      description.hashCode ^
      startTime.hashCode ^
      startTimestamp.hashCode ^
      endTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EPG &&
          runtimeType == other.runtimeType &&
          epgId == other.epgId &&
          title == other.title &&
          description == other.description &&
          startTime == other.startTime &&
          startTimestamp == other.startTimestamp &&
          endTime == other.endTime;
}

class Filters {
  final String? query;
  final Int64List sourceIds;
  final Uint8List? mediaTypes;
  final int viewType;
  final int page;
  final PlatformInt64? seriesId;
  final PlatformInt64? groupId;
  final bool useKeywords;

  const Filters({
    this.query,
    required this.sourceIds,
    this.mediaTypes,
    required this.viewType,
    required this.page,
    this.seriesId,
    this.groupId,
    required this.useKeywords,
  });

  @override
  int get hashCode =>
      query.hashCode ^
      sourceIds.hashCode ^
      mediaTypes.hashCode ^
      viewType.hashCode ^
      page.hashCode ^
      seriesId.hashCode ^
      groupId.hashCode ^
      useKeywords.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Filters &&
          runtimeType == other.runtimeType &&
          query == other.query &&
          sourceIds == other.sourceIds &&
          mediaTypes == other.mediaTypes &&
          viewType == other.viewType &&
          page == other.page &&
          seriesId == other.seriesId &&
          groupId == other.groupId &&
          useKeywords == other.useKeywords;
}

class Settings {
  final String? recordingPath;
  final String? mpvParams;
  final bool? useStreamCaching;
  final int? defaultView;
  final int? volume;
  final bool? refreshOnStart;
  final int? restreamPort;

  const Settings({
    this.recordingPath,
    this.mpvParams,
    this.useStreamCaching,
    this.defaultView,
    this.volume,
    this.refreshOnStart,
    this.restreamPort,
  });

  @override
  int get hashCode =>
      recordingPath.hashCode ^
      mpvParams.hashCode ^
      useStreamCaching.hashCode ^
      defaultView.hashCode ^
      volume.hashCode ^
      refreshOnStart.hashCode ^
      restreamPort.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Settings &&
          runtimeType == other.runtimeType &&
          recordingPath == other.recordingPath &&
          mpvParams == other.mpvParams &&
          useStreamCaching == other.useStreamCaching &&
          defaultView == other.defaultView &&
          volume == other.volume &&
          refreshOnStart == other.refreshOnStart &&
          restreamPort == other.restreamPort;
}

class Source {
  final PlatformInt64? id;
  final String name;
  final String? url;
  final String? urlOrigin;
  final String? username;
  final String? password;
  final int sourceType;
  final bool enabled;

  const Source({
    this.id,
    required this.name,
    this.url,
    this.urlOrigin,
    this.username,
    this.password,
    required this.sourceType,
    required this.enabled,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      url.hashCode ^
      urlOrigin.hashCode ^
      username.hashCode ^
      password.hashCode ^
      sourceType.hashCode ^
      enabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Source &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          url == other.url &&
          urlOrigin == other.urlOrigin &&
          username == other.username &&
          password == other.password &&
          sourceType == other.sourceType &&
          enabled == other.enabled;
}
