// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `apply_migrations`, `channel_headers_empty`, `create_connection_pool`, `create_or_find_source_by_name`, `create_structure`, `edit_custom_channel_tx`, `generate_placeholders`, `get_and_create_sqlite_db_path`, `get_conn`, `get_keywords_sql`, `get_or_insert_group`, `insert_channel_headers`, `insert_channel`, `insert_season`, `row_to_channel_headers`, `row_to_channel_preserve`, `row_to_channel`, `row_to_group_preserve`, `row_to_group`, `row_to_id_name`, `row_to_source`, `search_hidden`, `search_series`, `season_row_to_channel`, `series_has_episodes`, `set_channel_group_id`, `structure_exists`, `to_sql_like`, `to_to_sql`
// These functions are ignored because they have generic arguments: `do_tx`

Future<void> createOrInitializeDb() =>
    RustLib.instance.api.crateApiSqlCreateOrInitializeDb();

Future<void> dropDb() => RustLib.instance.api.crateApiSqlDropDb();

Future<ChannelHttpHeaders?> getChannelHeadersById({
  required PlatformInt64 id,
}) => RustLib.instance.api.crateApiSqlGetChannelHeadersById(id: id);

Future<Map<String, String>> getSettings() =>
    RustLib.instance.api.crateApiSqlGetSettings();

Future<void> updateSettings({required Map<String, String> map}) =>
    RustLib.instance.api.crateApiSqlUpdateSettings(map: map);

Future<List<Channel>> search({required Filters filters}) =>
    RustLib.instance.api.crateApiSqlSearch(filters: filters);

Future<List<Channel>> searchGroup({required Filters filters}) =>
    RustLib.instance.api.crateApiSqlSearchGroup(filters: filters);

Future<void> deleteChannelsBySource({
  required Transaction tx,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSqlDeleteChannelsBySource(
  tx: tx,
  sourceId: sourceId,
);

Future<void> deleteSeasonsBySource({
  required Transaction tx,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSqlDeleteSeasonsBySource(
  tx: tx,
  sourceId: sourceId,
);

Future<void> deleteGroupsBySource({
  required Transaction tx,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSqlDeleteGroupsBySource(
  tx: tx,
  sourceId: sourceId,
);

Future<void> deleteSource({required PlatformInt64 id}) =>
    RustLib.instance.api.crateApiSqlDeleteSource(id: id);

Future<BigInt> getChannelCountBySource({required PlatformInt64 id}) =>
    RustLib.instance.api.crateApiSqlGetChannelCountBySource(id: id);

Future<bool> sourceNameExists({required String name}) =>
    RustLib.instance.api.crateApiSqlSourceNameExists(name: name);

Future<void> favoriteChannel({
  required PlatformInt64 channelId,
  required bool favorite,
}) => RustLib.instance.api.crateApiSqlFavoriteChannel(
  channelId: channelId,
  favorite: favorite,
);

Future<void> hideChannel({
  required PlatformInt64 channelId,
  required bool hidden,
}) => RustLib.instance.api.crateApiSqlHideChannel(
  channelId: channelId,
  hidden: hidden,
);

Future<void> hideGroup({
  required PlatformInt64 groupId,
  required bool hidden,
}) =>
    RustLib.instance.api.crateApiSqlHideGroup(groupId: groupId, hidden: hidden);

Future<void> removeLastWatched({required PlatformInt64 channelId}) =>
    RustLib.instance.api.crateApiSqlRemoveLastWatched(channelId: channelId);

Future<List<Source>> getSources() =>
    RustLib.instance.api.crateApiSqlGetSources();

Future<List<Source>> getEnabledSources() =>
    RustLib.instance.api.crateApiSqlGetEnabledSources();

Future<Source> getSourceFromId({required PlatformInt64 sourceId}) =>
    RustLib.instance.api.crateApiSqlGetSourceFromId(sourceId: sourceId);

Future<void> setSourceEnabled({
  required bool value,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSqlSetSourceEnabled(
  value: value,
  sourceId: sourceId,
);

Future<void> addCustomChannel({
  required Transaction tx,
  required CustomChannel channel,
}) =>
    RustLib.instance.api.crateApiSqlAddCustomChannel(tx: tx, channel: channel);

Future<Source> getCustomSource({required String name}) =>
    RustLib.instance.api.crateApiSqlGetCustomSource(name: name);

Future<void> editCustomChannel({required CustomChannel channel}) =>
    RustLib.instance.api.crateApiSqlEditCustomChannel(channel: channel);

Future<void> deleteCustomChannel({required PlatformInt64 id}) =>
    RustLib.instance.api.crateApiSqlDeleteCustomChannel(id: id);

Future<bool> groupExists({
  required String name,
  required PlatformInt64 sourceId,
}) =>
    RustLib.instance.api.crateApiSqlGroupExists(name: name, sourceId: sourceId);

Future<bool> channelExists({
  required String name,
  required String url,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSqlChannelExists(
  name: name,
  url: url,
  sourceId: sourceId,
);

Future<PlatformInt64> addCustomGroup({
  required Transaction tx,
  required Group group,
}) => RustLib.instance.api.crateApiSqlAddCustomGroup(tx: tx, group: group);

Future<List<IdName>> groupAutoComplete({
  String? query,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSqlGroupAutoComplete(
  query: query,
  sourceId: sourceId,
);

Future<void> updateSource({required Source source}) =>
    RustLib.instance.api.crateApiSqlUpdateSource(source: source);

Future<void> wipe({required Transaction tx, required PlatformInt64 id}) =>
    RustLib.instance.api.crateApiSqlWipe(tx: tx, id: id);

Future<List<ChannelPreserve>> getPreserve({
  required Transaction tx,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSqlGetPreserve(tx: tx, sourceId: sourceId);

Future<void> restorePreserve({
  required Transaction tx,
  required PlatformInt64 sourceId,
  required List<ChannelPreserve> preserve,
}) => RustLib.instance.api.crateApiSqlRestorePreserve(
  tx: tx,
  sourceId: sourceId,
  preserve: preserve,
);

Future<void> analyze({required Transaction tx}) =>
    RustLib.instance.api.crateApiSqlAnalyze(tx: tx);

Future<void> addLastWatched({required PlatformInt64 id}) =>
    RustLib.instance.api.crateApiSqlAddLastWatched(id: id);

Future<void> clearHistory() => RustLib.instance.api.crateApiSqlClearHistory();

Future<void> updateSourceLastUpdated({required PlatformInt64 sourceId}) =>
    RustLib.instance.api.crateApiSqlUpdateSourceLastUpdated(sourceId: sourceId);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
abstract class Transaction implements RustOpaqueInterface {}
